// # Using file_get()
-	The file_get() function will retrieve files, reformat the input based on provided rules, and provide
the newly formatte output as a ds_queue.  In addition to the formatting rules, a FAST database can make
use of formatting directives and features.

	// # Directives
	-	Directives are commands to the file_get() routine.  They are not typically added to the output,
	but affect how the files are being read and formatted.
	
		#include	"foo"		- will open and insert the file "foo", if it exists, into the current input.
		
		#format		"foo"		- defines the rules use to format the output. Read the section on writing
			a format for information on how to create a format.
			
		#start	"foo"			- provides markers in the output. By default, the filename the input came
			from will be inserted allowing parsing routines to better identify sources of errors or
			current progress.
			
		#end					- compliments #start, returns to the previously specified marker
	
	// # comments
	-	file_get() supports commenting. All comments are discarded during file formatting.  There are two
	comment styles: single-line and multi-line. file_get() does not support intra-line comments, trying to
	do so will cause formatting to cease.  This is a limitation of how comments are recognized and parsed.
		// # single-line comments
		-	Single line comments are prefixed with // and will remove everything following them.  Processing
		will begin on the next line.
			- Syntax
			foo = 3; // my comment
		
			  or
		  
			// my comment
		
		// # multi-line comments "/*" and "*/"
		-	Multi-line comments start on one line and end on another.  Everything following a /* will
		be removed, as will everything preceeding the */.  Processing will stop at the /* and not continue
		until a */ is reached again.  If /* and */ are on the same line, formatting will halt entirely and
		not continue. Intra-line comments are not supported.
			- Syntax
			
			foo = 3 /* testing a
			multi-line
			comment */ bar = 1;
			
			Everything between the /* and */ are removed, the rest will be formatted.
			
			foo = 3
			bar = 1;
			
// # The FAST database
-	The FAST database is used to load external files into a custom data structure.  The database is made up
of "nodes" and "values".  Nodes are used to store key/value pairs, whereas values can be strings, numbers, 
other nodes, symbolic links or even new, custom data types you write yourself.  Data can be traversed from
a node through it's values to find data stored within:

	node(0) -v
		foo	= 1;
		bar	= node(1) -v
			foo		= 1;
			bar		= 2;
			
	You can retrieve the contents of a node using node_get() and specifying the path to the data you want
	to retrieve:
	
		node_get( 0, "bar.bar" );
	
// # basic syntax
The core of a FAST database is the FAST database-formatted file.  The FAST database breaks up inputs
between a left-hand and right-hand input. When there is no right hand value, the system will behave
as if it were "undefined".  The database reserves the characters @ and $ to indicate static values
and directives, ; to separate commands, the = character to divide commands into left and right-hand
values, and the { and } brackets to specify node starts and ends.
	
	foo;
	
	  or
	  
	foo = bar;
	
	  or
	  
	foo = { bar }
	
// # the ; character
The FAST database uses a semi-colon to break apart commands that are on the same line.
	Syntax -
	foo = 3; bar = 1;

// # left-hand values
The left-hand value can be a directive, a static declaration, a file marker, or a declaration.  If a
left-hand value can not be matched to something else, it will be treated as a declaration.
	// # static value declarations, "@"
	-	Static declarations are values that are not saved in the database, but can be used as the
	right-hand value of a declaration.  When a static declaration is used as a right-hand value, 
	including for other static values, it will be replaced. Static values persist for the loading
	sequence.  If you redeclare a static value, a warning will be given in the output log and the
	duplicate will be ignored.  A static value can contain any alphanumeric character and the .
	character.  Other characters will not generate warnings, but may cause unexpected results.
		Syntax -
		
		@static.value	= 10;
		
	// file markers
	-	File markers are automatically generated by the loading sequence. It is possible to enter
	them manually, however.  This only affects warning displays, but could be used to isolate
	sections of large files.
		Syntax -
		
		#start foo
		
		#end
	
	// directives
	-	Directives are commands for the loading process.  They are provide tools to make writing
	databases easier and less verbose.
	
		$template:foo		- the template directive will cause all further nodes in the current branch
			to inherit node "foo" before the inline template.
			
		$template:			- if a template was previously set, this will unset it.
		
		$include:foo		- the include directive will inherit node "foo" into the current node.
		
		$datatype:foo		- a right-hand value that does no declare a data type will be treated as
			a string or number.  The datatype directive will cause all undeclared datatypes to be
			treated as "foo" instead.
			
		$datatype:			- returns value data type declarations to normal.
		
		$pointer:foo		- When a database is loaded, either the root node or a map of nodes must
			be provided.  If a map is provided, the pointer direction will look up "foo" in the map
			and, if found, set as the current node for further processing.
			
	// declaration
	-	If one of the other left-hand values are not matched, the value will be treated as a normal
	declaration.  The database is made up of "nodes" and "values".  A declaration will either create
	a new node, create a new value, or overwrite a new value.  There is one special exception: symbolic
	links.  If a declaration is provided with a template but no right-hand value, it will be created
	as a symbolic link: that value will be treated as if it were actually the linked node with the sole
	exception that overwriting a symbolic link will not destroy the linked node.
		Syntax -
		
		foo;				- will create a new, undefined value.
		foo:bar;			- will create a symbolic link to bar.
		
		foo	= {				- will create a new node
		foo:bar	= {			- will create a new node that inherits from "bar"
		foo	= bar;			- will create a new value, foo, and assign bar to it
		
		}					- closes a node
		
// # right-hand values
The right hand value must be a data type or a static value.  If the data type is not specified, a value
be inferred as either a number or string based on formatting.
		Syntax -
		
		foo = {				- will create a new node
		
		foo = ${			- will destroy the current value and replace it. this is provided as a way
			to remove templated values, and override inherited symbolic links.  Links are treated, for
			purposes of traversal as the nodes themselves.  If you inherit a symbolic link and try to
			overwrite a value, it will overwrite the values on the linked node.  If you wish to override
			that link altogether, you must use ${.
		
		foo	= bar			- undeclared type, attempts to convert to a number. numbers can be in
			the interger format (0, 1, -14), decimal format, (1.2, 34.986), or hexidemical format
			using 0x (0x01, 0xF000).
			
		foo = "bar"			- undeclared type, will be converted to a string.
		foo = $type:bar		- bar will be declared as type. by default FAST has two built in data
			types, string and asset. Strings will be run through FAST's string_create() function and
			stored.  Asset will try to convert bar to an internal asset id.
			
		foo = (bar)			- When encapsulated in ()'s, values can be added and substracted using +
			and -.  Values can be static, but all values will be converted to numbers.  It is not
			possible to concantate other data types.

// # database directives
These directives affect how values are processed and assigned in the database.  There is one special case,
any root node named "template" will be discarded once loading has completed.  This only affects a root node
with that name.

@value	= some_value		- will create a static value that can then be referenced by using
								some_value = @value
							 
$template:node_path			- will set the defined node to be the default template for all other
							  nodes in the current branch.

$template:					- will clear the currently defined template
							  
$include:node_path			- will include the defined node in the current node

$datatype:type				- values with an undefined type will have the defined type instead, use

$datatype:					- will clear the currently defined default datatype

node:node_path	= {}		- equivalent to
								node = { $include:node_path; }
								
// # datatype
By default, any value is treated as a number.  To use other datatypes, or static values, the entries
must be formatted as follows.

value	= @static_value		- sets value to be the contents of @static_value

value	= $type:value		- converts value to the custom datatype <type> and assigns it to value

value	= "my string"		- sets value to be equal to the defined string

value	= 0x0000			- sets value to be equal to the converted hexidecimal value

value	= some_value		- by default, any non-typed value will be converted to a number.

// # custom datatypes
A custom datatype must be declared before the file is read, and can be done using

	database_define_datatype( "type", script );
	
When the "type" is used, the right hand value will be passed to the define script.  The script will recieve
the right hand value as argument0, and must return a value.  If the value `undefined` is returned, the
parser will throw ERROR_NONFATAL and skip the entry, this can be used to validate and flag an input that
is incorrect.  For example, the built-in datatype "$string" is defined:

	database_define_datatype( "string", __FASTdatatype_string );
	
The script itself returns the result of `string_create()`

/// @func *private __FASTdatatype_string( value )
datatype	= VALUE.ARRAY;

return string_create( string_copy( argument0, 2, string_length( argument0 ) - 2 ) );

Lastly, the global variable "datatype" can be set to use a specific value type.  By default a custom
datatype will have the type VALUE.OTHER, but you can change it to whatever you would like by setting
this variable.  This is how you can create custom datatypes for the parser to interpret.

// # formats
By default, no formatting changes are made to a file that is loaded by FAST.  However, to assist with file
parsing, the file can be formatted according to rules specified by the user.  The built-in FAST database
requires a specific format in order to be read properly, but you can also define your own if you wish to
write a loading routine of your own.

	A rule has the format "c:RULE" or "c:RULE+RULE"
	
c is a SINGLE CHARACTER such as a space, tab, number, letter, etc...

RULE is one of the following
	STRIP		- removes the character
		eg:	" :STRIP" would remove all spaces from the input text
		
	LINE		- creates a new line
		eg: ";:STRING" would start a new line after every ;
		
	PUSH		- creates a new line starting with this character
		eg: "}:PUSH" would create a new line starting with "}"
		
	SAFE		- toggles formating preservation
		you may have text you do not want to be affected by other rules.  the SAFE rule will
		toggle formatting preservation to ignore all rules until it is turned off.
		
		eg: "\":SAFE" would ignore all formatting rules until another " is read
		
	SAFE0		- turns formatting preservation on
	SAFE1		- turns formatting preservation off
	
	BREAK		- toggles read inputs
		when read input is off, all content of the file is ignored.
		
		eg: "*:BREAK" would ignore file contents until another * is read.
		
	BREAK0		- turns read inputs off
	BREAK1		- turns read inputs on
	
	PRESERVE	- ignores the next read character
		you may wish to use a character that has been defined as a rule above, in that case
		you can create a preserve character which will ignore formatting rules for the next
		character read.
		
		eg: "\\:PRESERVE" would ignore formatting for any character following a \
		